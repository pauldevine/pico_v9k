#include "pico/stdlib.h"
#include "hardware/pio.h"
#include "hardware/dma.h"
#include "hardware/structs/systick.h"
#include "hardware/sync.h"  // For __dmb() memory barrier
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "pico_victor/dma.h"
#include "logging.h"
#include "reg_queue_processor.h"
#include "sasi.h"
#include "pico_storage/storage.h"
#include "pico_fujinet/spi.h"

// Set to 1 to enable SASI debug printf (WARNING: slows Core 1 dramatically, causes queue overflow)
#define SASI_DEBUG_PRINTF 0
// Set to 1 to enable SASI fast_log tracing (WARNING: causes queue overflow)
#define SASI_DEBUG_FASTLOG 0
// Set to 1 to enable DMA read verification for WRITE(6) testing (verifies data read from Victor RAM)
#define SASI_DMA_READ_VERIFY 0
// Set to 1 to enable DMA write verification for READ(6) (reads back data after writing to Victor RAM)
#define SASI_DMA_WRITE_VERIFY 0
// Set to 1 to automatically dump SASI trace to UART on each reset after the first.
// Keep disabled in timing-sensitive boots to avoid heavy UART latency.
#ifndef SASI_TRACE_AUTODUMP_ON_RESET
#define SASI_TRACE_AUTODUMP_ON_RESET 0
#endif

#if SASI_DEBUG_PRINTF
#define sasi_printf(...) printf(__VA_ARGS__)
#else
#define sasi_printf(...) ((void)0)
#endif

#if SASI_DEBUG_FASTLOG
#define sasi_fastlog(...) fast_log(__VA_ARGS__)
#else
#define sasi_fastlog(...) ((void)0)
#endif

#if SASI_DMA_READ_VERIFY || SASI_DMA_WRITE_VERIFY
/*
 * CRC-8 calculation using polynomial 0x07 (x^8 + x^2 + x + 1)
 * Used for verifying DMA transfers during testing.
 */
static uint8_t sasi_crc8(const uint8_t *data, uint16_t len) {
    uint8_t crc = 0x00;
    for (uint16_t i = 0; i < len; i++) {
        crc ^= data[i];
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x80) {
                crc = (crc << 1) ^ 0x07;
            } else {
                crc <<= 1;
            }
        }
    }
    return crc;
}
#endif

#if SASI_DMA_READ_VERIFY
/*
 * Compute expected CRC for test pattern: byte[i] = (lba + i) & 0xFF
 * This matches the pattern generated by the DOS-side dma_verify.c test.
 */
static uint8_t compute_expected_pattern_crc(uint32_t lba) {
    uint8_t crc = 0x00;
    for (uint16_t i = 0; i < 512; i++) {
        uint8_t byte = (uint8_t)((lba + i) & 0xFF);
        crc ^= byte;
        for (uint8_t j = 0; j < 8; j++) {
            if (crc & 0x80) {
                crc = (crc << 1) ^ 0x07;
            } else {
                crc <<= 1;
            }
        }
    }
    return crc;
}
#endif // SASI_DMA_READ_VERIFY

// SASI command state - file-scope so it can be reset on device reset
static uint8_t sasi_command_buffer[16];
static int sasi_cmd_index = 0;

// Diagnostic trace buffer - records last N events for post-mortem debugging
static sasi_trace_t sasi_trace;

void sasi_trace_init(void) {
    memset(&sasi_trace, 0, sizeof(sasi_trace));
}

void sasi_trace_event(sasi_trace_type_t type, uint8_t value, uint8_t cmd_idx, uint8_t bus_ctrl) {
    uint32_t idx = sasi_trace.head & (SASI_TRACE_SIZE - 1);
    sasi_trace.entries[idx].type = (uint8_t)type;
    sasi_trace.entries[idx].value = value;
    sasi_trace.entries[idx].cmd_index = cmd_idx;
    sasi_trace.entries[idx].bus_ctrl = bus_ctrl;
    sasi_trace.entries[idx].seq = sasi_trace.seq++;
    sasi_trace.head++;
}

void sasi_trace_dump(void) {
    static const char *type_names[] = {
        "CMD_BYTE", "CMD_DONE", "STATUS", "MSG", "BUS_FREE",
        "DMA_RD", "DMA_WR", "RESET", "SELECT", "DATA_RD", "STAT_RD", "DATA_OUT", "DO_SETUP"
    };

    printf("\n=== SASI TRACE (last %d events) ===\n", SASI_TRACE_SIZE);
    printf("Seq   Type      Val  Idx  BusCtrl\n");
    printf("----  --------  ---  ---  -------\n");

    // Find oldest entry
    uint32_t start = (sasi_trace.head >= SASI_TRACE_SIZE) ?
                     sasi_trace.head - SASI_TRACE_SIZE : 0;
    uint32_t count = (sasi_trace.head >= SASI_TRACE_SIZE) ?
                     SASI_TRACE_SIZE : sasi_trace.head;

    for (uint32_t i = 0; i < count; i++) {
        uint32_t idx = (start + i) & (SASI_TRACE_SIZE - 1);
        sasi_trace_entry_t *e = &sasi_trace.entries[idx];
        const char *name = (e->type < 13) ? type_names[e->type] : "???";
        printf("%4lu  %-8s  %02X   %d    %02X\n",
               (unsigned long)e->seq, name, e->value, e->cmd_index, e->bus_ctrl);
    }
    printf("=== END TRACE ===\n\n");
}

void sasi_reset_command_state(void) {
    // Auto-dump trace on reset if we've seen any commands
    // This helps debug when Victor retries initialization
    static int reset_count = 0;
    reset_count++;
#if SASI_TRACE_AUTODUMP_ON_RESET
    if (sasi_trace.head > 0 && reset_count > 1) {
        printf("\n!!! SASI RESET #%d - Auto-dumping trace !!!\n", reset_count);
        sasi_trace_dump();
    }
#endif

    sasi_cmd_index = 0;
    // Optionally clear buffer for cleaner debugging
    for (int i = 0; i < 16; i++) {
        sasi_command_buffer[i] = 0;
    }
    sasi_trace_event(TRACE_RESET, 0, 0, 0);
}

static void sasi_apply_command_delay(dma_registers_t *dma) {
    if (!dma || SASI_COMMAND_DELAY_US == 0) {
        return;
    }

    // Hold command phase busy (BSY|CTL, no REQ) while the controller "executes".
    dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_INP_BIT | SASI_ACK_BIT);
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_CTL_BIT);
    __dmb();  // Ensure Core 0 sees bus_ctrl update
    cached_status_sync_from_bus(dma);

    sleep_us(SASI_COMMAND_DELAY_US);
}

static void sasi_request_cmd_byte(dma_registers_t *dma) {
    // Controller requests next command byte: BSY|REQ|CTL, I/O=0 (host->dev)
    uint8_t before = dma->bus_ctrl;
    // Drop ACK between bytes and ensure we're in command phase.
    dma->bus_ctrl &= ~(SASI_ACK_BIT | SASI_MSG_BIT);
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_REQ_BIT | SASI_CTL_BIT);
    dma->bus_ctrl &= ~SASI_INP_BIT; // host -> controller
    __dmb();  // Ensure bus_ctrl update is complete
    dma->state.non_dma_req = 1;
    // CRITICAL: Update cache BEFORE asserting interrupt!
    cached_status_sync_from_bus(dma);
    __dmb();  // Ensure cache write is visible to Core 0
    dma_update_interrupts(dma, true);
    sasi_fastlog("SASI: request_cmd_byte done, bus_ctrl 0x%02X->0x%02X\n", before, dma->bus_ctrl);
}

static void sasi_enter_status_phase(dma_registers_t *dma, uint8_t status_byte) {
    // Prepare to send status: BSY|REQ|CTL|INP
    sasi_fastlog("SASI: entering status phase, status=0x%02X, irq_pend=%d\n",
             status_byte, dma->state.interrupt_pending);
    sasi_trace_event(TRACE_STATUS_PHASE, status_byte, 0, dma ? dma->bus_ctrl : 0);
    dma->status = status_byte;
    cached_set_data(status_byte);
    dma->bus_ctrl &= ~SASI_ACK_BIT;
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_REQ_BIT | SASI_CTL_BIT | SASI_INP_BIT);
    dma->bus_ctrl &= ~SASI_MSG_BIT;
    __dmb();  // Ensure bus_ctrl update is complete
    dma->state.non_dma_req = 1;
    dma->state.status_pending = 1;  // Mark that we're waiting for host to read status
    // CRITICAL: Update cache BEFORE asserting interrupt!
    // Host polls immediately after seeing IR4 - cache must be ready.
    cached_status_sync_from_bus(dma);
    __dmb();  // Ensure cache write is visible to Core 0
    dma_update_interrupts(dma, true);
    sasi_fastlog("SASI: status phase ready, bus_ctrl=0x%02X, irq_pend=%d\n",
             dma->bus_ctrl, dma->state.interrupt_pending);
}

static void sasi_enter_message_phase(dma_registers_t *dma) {
    // Move to message in: BSY|REQ|CTL|INP|MSG (single 0x00 completion message)
    sasi_trace_event(TRACE_MSG_PHASE, 0x00, 0, dma ? dma->bus_ctrl : 0);
    cached_set_data(0x00);
    dma->bus_ctrl &= ~SASI_ACK_BIT;
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_REQ_BIT | SASI_CTL_BIT | SASI_INP_BIT | SASI_MSG_BIT);
    __dmb();  // Ensure bus_ctrl update is complete
    dma->state.non_dma_req = 1;
    // CRITICAL: Update cache BEFORE asserting interrupt!
    cached_status_sync_from_bus(dma);
    __dmb();  // Ensure cache write is visible to Core 0
    dma_update_interrupts(dma, true);
}

static void sasi_release_bus(dma_registers_t *dma) {
    // Drop REQ/BSY and clear control lines to idle
    sasi_trace_event(TRACE_BUS_FREE, 0, 0, dma ? dma->bus_ctrl : 0);
    dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_BSY_BIT | SASI_CTL_BIT | SASI_INP_BIT | SASI_MSG_BIT | SASI_ACK_BIT);
    __dmb();  // Ensure Core 0 sees bus_ctrl cleared
    dma_update_interrupts(dma, false);
    cached_status_sync_from_bus(dma);
    cached_set_data(0x00);  // Avoid stale DATA reads after bus free
}

void route_to_sasi_target(dma_registers_t *dma, uint8_t *cmd, int len) {
    switch (cmd[0]) {
        case 0x00: // Test Unit Ready
            handle_test_unit_ready(dma);
            break;

        case 0x01: // Recalibrate/Rezero Unit - treat same as Test Unit Ready for now
            sasi_printf("SASI: Recalibrate/Rezero Unit\n");
            handle_test_unit_ready(dma);  // Return GOOD status
            break;

        case XEBEC_RAM_DIAG:      // 0xE0 - Xebec RAM diagnostic
        case XEBEC_DRIVE_DIAG:    // 0xE3 - Xebec drive interface diagnostic
        case XEBEC_INTERNAL_DIAG: // 0xE4 - Xebec internal diagnostic
            handle_xebec_diagnostic(dma, cmd[1]); // Second byte is diagnostic subtype
            break;

        case 0x08: // Read(6)
            handle_read_sectors(dma, cmd);
            break;

        case 0x03: // Request Sense (BIOS uses 0x08 for READ, 0x03 is always SENSE)
            handle_request_sense(dma, cmd);
            break;

        case 0x0A: // Write(6)
            handle_write_sectors(dma, cmd);
            break;

        case 0x0C: // Initialize Drive Characteristics (Xebec SET DRIVE PARAMS)
            // Victor 9000 boot expects an 8-byte data-out parameter list (boot label ctlprm).
            // RaSCSI Victor9k fork accepts 8 bytes during DATA OUT for this opcode.
            // Prefer DMA-based transfer when DMA is enabled; otherwise fall back to DATA register writes.
            sasi_printf("SASI: Initialize Drive Characteristics (Set Drive Params)\n");
            if (dma && dma->state.dma_enabled) {
                uint8_t params[8];
                // Enter DATA OUT phase: BSY asserted, CTL=0, INP=0.
                dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_CTL_BIT | SASI_INP_BIT | SASI_ACK_BIT);
                dma->bus_ctrl |= SASI_BSY_BIT;
                __dmb();
                cached_status_sync_from_bus(dma);

                // Read parameter bytes from Victor RAM via DMA.
                dma_read_from_victor_ram(params, sizeof(params), dma->dma_address.full);
                dma->dma_address.full += sizeof(params);
                cached_sync_dma_address(dma);

                // Complete with GOOD status.
                signal_command_complete(dma);
            } else if (dma) {
                // Non-DMA path: request 8 data-out bytes via DATA register.
                dma->buffer.index = 0;
                dma->state.data_out_expected = 8;
                dma->bus_ctrl &= ~(SASI_MSG_BIT | SASI_CTL_BIT | SASI_INP_BIT | SASI_ACK_BIT);
                dma->bus_ctrl |= (SASI_BSY_BIT | SASI_REQ_BIT);
                __dmb();
                dma->state.non_dma_req = 1;
                cached_status_sync_from_bus(dma);
                dma_update_interrupts(dma, true);
            } else {
                signal_command_complete(dma);
            }
            break;

        case 0x15: // Mode Select(6)
            handle_mode_select(dma, cmd);
            break;

        default:
            // Unknown command - return GOOD status anyway to not block boot
            sasi_printf("SASI: Unknown command 0x%02X, returning GOOD status\n", cmd[0]);
            signal_command_complete(dma);
            break;
    }
}

void handle_sasi_command_byte(dma_registers_t *dma, uint8_t cmd_byte) {
    sasi_fastlog("SASI: handle_cmd_byte entry idx=%d byte=0x%02X\n", sasi_cmd_index, cmd_byte);
    sasi_printf("SASI CMD[%d] = 0x%02X\n", sasi_cmd_index, cmd_byte);
    sasi_trace_event(TRACE_CMD_BYTE, cmd_byte, sasi_cmd_index, dma ? dma->bus_ctrl : 0);
    sasi_command_buffer[sasi_cmd_index++] = cmd_byte;

    // First byte is the opcode - log recognized commands
    if (sasi_cmd_index == 1) {
        switch (cmd_byte) {
            case 0x00:
                sasi_printf("SASI: Test Unit Ready\n");
                break;
            case 0x01:
                sasi_printf("SASI: Recalibrate/Rezero Unit\n");
                break;
            case 0x03:
                sasi_printf("SASI: Request Sense\n");
                break;
            case 0x08:
                sasi_printf("SASI: Read(6)\n");
                break;
            case 0x0A:
                sasi_printf("SASI: Write(6)\n");
                break;
            case 0x0C:
                sasi_printf("SASI: Initialize Drive Characteristics\n");
                break;
            case 0x15:
                sasi_printf("SASI: Mode Select(6)\n");
                break;
            case XEBEC_RAM_DIAG:
                sasi_printf("SASI: Xebec RAM Diagnostic 0xE0\n");
                break;
            case XEBEC_DRIVE_DIAG:
                sasi_printf("SASI: Xebec Drive Diagnostic 0xE3\n");
                break;
            case XEBEC_INTERNAL_DIAG:
                sasi_printf("SASI: Xebec Internal Diagnostic 0xE4\n");
                break;
            default:
                sasi_printf("SASI: Unknown opcode 0x%02X\n", cmd_byte);
                break;
        }
    }

    // When command is complete, route to appropriate handler
    if (command_complete(sasi_command_buffer, sasi_cmd_index)) {
        sasi_fastlog("SASI: command complete, routing opcode=0x%02X\n", sasi_command_buffer[0]);
        sasi_trace_event(TRACE_CMD_COMPLETE, sasi_command_buffer[0], sasi_cmd_index, dma ? dma->bus_ctrl : 0);
        route_to_sasi_target(dma, sasi_command_buffer, sasi_cmd_index);
        sasi_cmd_index = 0; // Reset for next command
    } else {
        // Request next byte per log sequence (BSY|REQ|CTL)
        sasi_fastlog("SASI: requesting next byte, idx=%d\n", sasi_cmd_index);
        sasi_request_cmd_byte(dma);
    }
}

// Handle a data-out phase byte (e.g., drive parameters for 0x0C)
// Returns true if more bytes expected, false if data-out phase complete
bool handle_sasi_data_out_byte(dma_registers_t *dma, uint8_t data_byte) {
    // Trace the data-out byte for debugging
    sasi_trace_event(TRACE_DATA_OUT, data_byte, dma ? dma->state.data_out_expected : 0, dma ? dma->bus_ctrl : 0);

    if (!dma || dma->state.data_out_expected == 0) {
        sasi_printf("SASI: Unexpected data-out byte 0x%02X\n", data_byte);
        return false;
    }

    // Store the byte in the buffer
    if (dma->buffer.index < 16) {
        dma->buffer.data[dma->buffer.index++] = data_byte;
    }
    dma->state.data_out_expected--;

    sasi_printf("SASI: Data-out byte[%d]=0x%02X, %d remaining\n",
               dma->buffer.index - 1, data_byte, dma->state.data_out_expected);

    if (dma->state.data_out_expected > 0) {
        // More bytes expected - request next byte (data-out phase: BSY|REQ, CTL=0, INP=0)
        dma->bus_ctrl &= ~(SASI_MSG_BIT | SASI_CTL_BIT | SASI_INP_BIT | SASI_ACK_BIT);
        dma->bus_ctrl |= (SASI_BSY_BIT | SASI_REQ_BIT);
        __dmb();
        dma->state.non_dma_req = 1;
        cached_status_sync_from_bus(dma);
        dma_update_interrupts(dma, true);
        return true;
    }

    // All bytes received - log the parameters and complete
    sasi_printf("SASI: Drive params complete (%d bytes):", dma->buffer.index);
    for (int i = 0; i < dma->buffer.index && i < 16; i++) {
        sasi_printf(" %02X", dma->buffer.data[i]);
    }
    sasi_printf("\n");

    // Clear the data-out state
    dma->buffer.index = 0;
    dma->buffer.length = 0;

    // Complete with GOOD status
    signal_command_complete(dma);
    return false;
}

void handle_read_sectors(dma_registers_t *dma, uint8_t *cmd) {
    // Parse Read(6) - command 0x08
    // cmd[1] (5 MSBs), cmd[2], cmd[3] = LBA, cmd[4] = count
    uint32_t sector = ((cmd[1] & 0x1F) << 16) | (cmd[2] << 8) | cmd[3];
    uint16_t blocks = cmd[4] ? cmd[4] : 256; // SASI Read(6): 0 means 256 blocks

    sasi_printf("RD sectors:%u starting: %u\n", (unsigned)blocks, (unsigned)sector);
    sasi_trace_event(TRACE_DMA_READ, (uint8_t)(sector & 0xFF), blocks, dma ? dma->bus_ctrl : 0);

    if (dma) {
        dma->logical_block.full = sector;
        dma->block_count.full = blocks;
    }

    sasi_apply_command_delay(dma);

    // During command processing, reflect COMMAND busy (BSY|CTL) like MAME traces.
    dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_INP_BIT | SASI_ACK_BIT);
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_CTL_BIT);
    __dmb();  // Ensure Core 0 sees bus_ctrl update
    cached_status_sync_from_bus(dma);

    // Simulate reading from disk and DMA to system RAM
#if SASI_DMA_WRITE_VERIFY
    uint32_t verify_start_addr = dma->dma_address.full;
#endif

    for (uint16_t i = 0; i < blocks; i++) {
        // Abort immediately if host sent a RESET while we were busy
        if (dma->reset_requested) {
            break;
        }

        uint8_t sector_data[512];
        read_sector_from_disk(dma, sector + i, sector_data);

        // Switch to DATA IN just before DMA transfer
        dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_CTL_BIT | SASI_ACK_BIT);
        dma->bus_ctrl |= (SASI_BSY_BIT | SASI_INP_BIT);
        __dmb();
        cached_status_sync_from_bus(dma);

        // DMA transfer to system RAM
        dma_write_to_victor_ram(sector_data, 512, dma->dma_address.full);

        // Auto-increment DMA address
        dma->dma_address.full += 512;

        // If more sectors remain, return to COMMAND busy while processing next sector
        if (i + 1 < blocks) {
            dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_INP_BIT | SASI_ACK_BIT);
            dma->bus_ctrl |= (SASI_BSY_BIT | SASI_CTL_BIT);
            __dmb();
            cached_status_sync_from_bus(dma);
        }
    }

    // If host reset during the loop, skip status — the queued reset
    // will clean up the bus state when Core 1 returns to the defer loop.
    if (dma->reset_requested) {
        return;
    }

#if SASI_DMA_WRITE_VERIFY
    // Verification: verify FIRST sector to check if DMA read-back works
    // Testing both on-board and expansion RAM
    {
        printf("VERIFY addr=%05lX ", (unsigned long)verify_start_addr);
        uint8_t expected[512];
        uint8_t readback[512];

        // Re-read expected data from disk
        read_sector_from_disk(dma, sector, expected);
        uint8_t expected_crc = sasi_crc8(expected, 512);

        // Read back just the first 8 bytes to minimize DMA time
        dma_read_from_victor_ram(readback, 8, verify_start_addr);

        // Quick check: compare first 8 bytes
        bool match = true;
        for (int j = 0; j < 8; j++) {
            if (expected[j] != readback[j]) {
                match = false;
                break;
            }
        }

        if (!match) {
            printf("DMA WR VERIFY FAIL: LBA %lu addr %05lX\n",
                   (unsigned long)sector, (unsigned long)verify_start_addr);
            printf("  Expected: %02X %02X %02X %02X %02X %02X %02X %02X\n",
                   expected[0], expected[1], expected[2], expected[3],
                   expected[4], expected[5], expected[6], expected[7]);
            printf("  Readback: %02X %02X %02X %02X %02X %02X %02X %02X\n",
                   readback[0], readback[1], readback[2], readback[3],
                   readback[4], readback[5], readback[6], readback[7]);
        }
    }
#endif

    if (dma) {
        dma->logical_block.full = sector + blocks;
        dma->block_count.full = 0;
    }

    // Signal completion to host
    cached_sync_dma_address(dma);
    signal_command_complete(dma);
}

void handle_write_sectors(dma_registers_t *dma, uint8_t *cmd) {
    // Parse Write(6)
    uint32_t sector = ((cmd[1] & 0x1F) << 16) | (cmd[2] << 8) | cmd[3];
    uint16_t blocks = cmd[4] ? cmd[4] : 256;

    sasi_printf("WR sectors:%u starting: %u\n", (unsigned)blocks, (unsigned)sector);
    sasi_trace_event(TRACE_DMA_WRITE, (uint8_t)(sector & 0xFF), blocks, dma ? dma->bus_ctrl : 0);

    if (dma) {
        dma->logical_block.full = sector;
        dma->block_count.full = blocks;
    }

    sasi_apply_command_delay(dma);

    // During command processing, reflect COMMAND busy (BSY|CTL).
    dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_INP_BIT | SASI_ACK_BIT);
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_CTL_BIT);
    __dmb();  // Ensure Core 0 sees bus_ctrl update
    cached_status_sync_from_bus(dma);

    uint8_t target = dma ? (dma->selected_target & 0x07) : 0;

    for (uint16_t i = 0; i < blocks; i++) {
        // Abort immediately if host sent a RESET while we were busy
        if (dma->reset_requested) {
            break;
        }

        uint8_t sector_data[512];
        // Switch to DATA OUT just before DMA read from Victor RAM
        dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_CTL_BIT | SASI_INP_BIT | SASI_ACK_BIT);
        dma->bus_ctrl |= SASI_BSY_BIT;
        __dmb();
        cached_status_sync_from_bus(dma);

        // Read from Victor RAM into local buffer
        dma_read_from_victor_ram(sector_data, 512, dma->dma_address.full);

#if SASI_DMA_READ_VERIFY
        // Verify DMA read against expected test pattern (for dma_verify.c round-trip test)
        // Pattern: byte[j] = (sector + i + j) & 0xFF
        uint8_t read_crc = sasi_crc8(sector_data, 512);
        uint8_t expected_crc = compute_expected_pattern_crc(sector + i);
        if (read_crc != expected_crc) {
            printf("DMA READ VERIFY FAIL: LBA %lu read_crc=0x%02X expected=0x%02X\n",
                   (unsigned long)(sector + i), read_crc, expected_crc);
            printf("  First 8 bytes: %02X %02X %02X %02X %02X %02X %02X %02X\n",
                   sector_data[0], sector_data[1], sector_data[2], sector_data[3],
                   sector_data[4], sector_data[5], sector_data[6], sector_data[7]);
        } else {
            printf("DMA READ VERIFY OK: LBA %lu CRC=0x%02X\n",
                   (unsigned long)(sector + i), read_crc);
        }
#endif // SASI_DMA_READ_VERIFY

        dma->dma_address.full += 512;

        // If more sectors remain, return to COMMAND busy while processing next sector
        if (i + 1 < blocks) {
            dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_INP_BIT | SASI_ACK_BIT);
            dma->bus_ctrl |= (SASI_BSY_BIT | SASI_CTL_BIT);
            __dmb();
            cached_status_sync_from_bus(dma);
        }

        // Try storage abstraction layer first (handles SD card, FujiNet, etc.)
        bool write_ok = false;
        if (storage_is_mounted(target)) {
            write_ok = storage_write_sector(target, sector + i, sector_data, 512);
        }

        // Fall back to FujiNet direct access if storage layer not available
        if (!write_ok) {
            uint8_t device = DEVICE_DISK_BASE + target;
            if (!fujinet_write_sector(device, sector + i, sector_data, 512)) {
                sasi_printf("Warning: write sector LBA %lu failed, continuing\n", (unsigned long)(sector + i));
            }
        }
    }

    // If host reset during the loop, skip status/sync — the queued reset
    // will clean up the bus state when Core 1 returns to the defer loop.
    if (dma->reset_requested) {
        return;
    }

    // Sync all written sectors to persistent storage in one operation
    if (storage_is_mounted(target)) {
        storage_sync(target);
    }

    if (dma) {
        dma->logical_block.full = sector + blocks;
        dma->block_count.full = 0;
    }

    cached_sync_dma_address(dma);
    signal_command_complete(dma);
}

void handle_request_sense(dma_registers_t *dma, uint8_t *cmd) {
    // Request Sense returns error information about the last command.
    // Per SASI specification (Shugart Associates System Interface):
    // - cmd[4] contains allocation length
    // - If allocation length is 0, transfer 4 bytes (SASI default)
    // - Data is transferred via DMA in Data-In phase
    //
    // SASI sense format (4 bytes minimum):
    //   Byte 0: Error code (upper byte of status code, 0x00 = no error)
    //   Byte 1: LUN (bits 7-5) | Logical block address MSB (bits 4-0)
    //   Byte 2: Logical block address middle byte
    //   Byte 3: Logical block address LSB

    int size = cmd[4];
    if (size == 0) {
        size = 4;  // SASI spec: 0 means transfer 4 bytes
    }
    if (size > 4) {
        size = 4;  // SASI only uses 4 bytes (SCSI uses more)
    }

    // Build sense data - no error condition
    uint8_t sense_data[4] = {0};
    sense_data[0] = 0x00;  // No error
    sense_data[1] = 0x00;  // LUN 0, no address
    sense_data[2] = 0x00;
    sense_data[3] = 0x00;

    sasi_printf("SASI: Request Sense, transferring %d bytes\n", size);

    // Enter Data-In phase: BSY asserted, I/O high (device->host), C/D low
    dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_CTL_BIT);
    dma->bus_ctrl |= (SASI_BSY_BIT | SASI_INP_BIT);  // INP=1 for data-in
    __dmb();
    cached_status_sync_from_bus(dma);

    // Transfer sense data to host via DMA
    dma_write_to_victor_ram(sense_data, size, dma->dma_address.full);
    dma->dma_address.full += size;
    cached_sync_dma_address(dma);

    // Complete with GOOD status
    signal_command_complete(dma);
}

void handle_mode_select(dma_registers_t *dma, uint8_t *cmd) {
    size_t param_len = cmd[4];
    if (param_len) {
        uint8_t params[256];
        if (param_len > sizeof(params)) param_len = sizeof(params);

        // Data-out phase: BSY asserted, I/O low, C/D low
        dma->bus_ctrl &= ~(SASI_REQ_BIT | SASI_MSG_BIT | SASI_CTL_BIT);
        dma->bus_ctrl |= SASI_BSY_BIT;
        dma->bus_ctrl &= ~SASI_INP_BIT;
        __dmb();  // Ensure Core 0 sees bus_ctrl update
        cached_status_sync_from_bus(dma);

        // Read parameter list from Victor RAM (ignore content for now)
        dma_read_from_victor_ram(params, param_len, dma->dma_address.full);
        dma->dma_address.full += param_len;
        cached_sync_dma_address(dma);
    }

    // Respond GOOD
    signal_command_complete(dma);
}
void handle_xebec_diagnostic(dma_registers_t *dma, uint8_t diagnostic_type) {
    sasi_printf("SASI: Executing diagnostic 0x%02X (opcode 0x%02X)\n", diagnostic_type, sasi_command_buffer[0]);

    // Execute diagnostic (always pass for now)
    // Diagnostics are non-data commands that complete immediately with status.
    // The host will read status via register 0x10 (DATA) when it sees REQ|CTL|INP.
    // The defer_process_read() handler will advance through status -> message -> bus free
    // as the host reads the DATA register.

    // Enter status phase with GOOD (0x00) status - host will read this from DATA register
    // The bus state machine in defer_process_read() handles the rest automatically:
    //   1. Host sees status 0x0F (REQ|CTL|INP|BSY)
    //   2. Host reads DATA register -> gets status byte (0x00)
    //   3. We transition to message phase (status becomes 0x1F)
    //   4. Host reads DATA register -> gets message byte (0x00)
    //   5. Bus is released (status becomes 0x00)
    signal_command_complete(dma);
}

bool command_complete(uint8_t *command_buffer, int cmd_index) {
    if (cmd_index == 0) return false;
    uint8_t op = command_buffer[0];

    // SASI/SCSI-1 commands are grouped by class (upper 3 bits of opcode):
    // Class 0 (0x00-0x1F): 6-byte CDB
    // Class 1 (0x20-0x3F): 10-byte CDB (not commonly used in SASI)
    // Class 7 (0xE0-0xFF): Vendor-specific (Xebec uses 6-byte)

    // All commands observed in Victor 9000 boot sequence are 6 bytes:
    // 0x00 - Test Unit Ready (6 bytes)
    // 0x01 - Recalibrate/Rezero (6 bytes)
    // 0x03 - Request Sense (6 bytes)
    // 0x08 - Read(6) (6 bytes)
    // 0x0A - Write(6) (6 bytes)
    // 0x0C - Initialize Drive Characteristics (6 bytes)
    // 0x15 - Mode Select(6) (6 bytes)
    // 0xE0 - Xebec RAM Diagnostic (6 bytes)
    // 0xE3 - Xebec Drive Diagnostic (6 bytes)
    // 0xE4 - Xebec Internal Diagnostic (6 bytes)

    return cmd_index >= 6;
}

void signal_command_complete(dma_registers_t *dma) {
    // After data/command phase, send GOOD status then message-in 0x00
    sasi_enter_status_phase(dma, 0x00);
    __dmb();  // Ensure bus_ctrl update is visible
}

void handle_test_unit_ready(dma_registers_t *dma) {
    // Respond immediately with GOOD status
    sasi_enter_status_phase(dma, 0x00);
}

void read_sector_from_disk(dma_registers_t *dma, uint32_t sector, uint8_t *buffer) {
    uint8_t target = dma ? (dma->selected_target & 0x07) : 0;

    // Try storage abstraction layer first (handles SD card, FujiNet, etc.)
    if (storage_is_mounted(target)) {
        if (storage_read_sector(target, sector, buffer, 512)) {
            return;
        }
        sasi_printf("Warning: storage_read_sector failed for target %d, LBA %lu\n",
                    target, (unsigned long)sector);
    }

    // Fall back to FujiNet direct access if storage layer not available
    uint8_t device = DEVICE_DISK_BASE + target;
    if (!fujinet_read_sector(device, sector, buffer, 512)) {
        // Last resort: generate deterministic test data
        for (int i = 0; i < 512; i++) buffer[i] = (uint8_t)((sector + i) & 0xFF);
    }
    sasi_printf("RD sector %lu target %d\n", (unsigned long)sector, target);
}
