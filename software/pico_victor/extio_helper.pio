.pio_version 1
.define RD_PIN 21
.program extio_helper

.wrap_target
    wait 1 irq 0        ; wake up when the board_registers SM asserts IRQ0
    set pindirs, 1 [30] ; drive the pin, give time for RD to go low
    wait 1 gpio RD_PIN  ; hang here until RD/ releases
    nop [7]            ; small delay to ensure stable release
    set pindirs, 0      ; tri-state EXTIO/ again
.wrap

% c-sdk {
#include <stdio.h>
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "pico_victor/dma.h"

static inline void extio_helper_program_init(PIO pio, uint sm, uint offset) {
    uint extio_offset = EXTIO_PIN - 16; // PIO pins start at GPIO16 for this base
    printf("Configuring PIO for EXTIO helper SM\n");
    pio_sm_config c = extio_helper_program_get_default_config(offset);

    sm_config_set_set_pins(&c, EXTIO_PIN, 1);
    pio_gpio_init(pio, EXTIO_PIN);
    gpio_set_drive_strength(EXTIO_PIN, GPIO_DRIVE_STRENGTH_12MA);
    gpio_disable_pulls(EXTIO_PIN);

    pio_gpio_init(pio, RD_PIN);

    // preload latch low, will use pindirs to toggle open-drain low as needed
    pio_sm_set_pins_with_mask(pio, sm, 0u, 1u << extio_offset); 
    pio_sm_set_consecutive_pindirs(pio, sm, extio_offset, 1, false);
    irq_clear(0);
    sm_config_set_clkdiv(&c, 1.0f);  

    // Load our configuration, and jump to the start of the program
    int init_rc = pio_sm_init(pio, sm, offset, &c);
    printf("pio_sm_init rc=%d, SM%d execctrl after init=0x%08x\n", init_rc, sm, pio->sm[sm].execctrl);
}

%}