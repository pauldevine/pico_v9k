; test_hold_hlda.pio - Minimal test for HOLD/HLDA handshaking
;
; This PIO program tests the basic bus arbitration using open-drain signaling:
; 1. Assert HOLD by enabling output (pulls low since output value is 0)
; 2. Wait for HLDA acknowledgment (pin 28 goes HIGH) - active high signal
; 3. Release HOLD by disabling output (lets it float high via pull-up)
; 4. Do timing delay
; 5. Wrap and repeat

.program test_hold_hlda
.side_set 1 opt pindirs  ; One side-set pin for HOLD direction control, optional

.define public HOLD_PIN  25
.define public HLDA_PIN  28

    ; Assert HOLD by enabling output direction (will drive low since pin value is 0)
    nop         side 1      ; Side-set pindir=1 (output enabled), pulls HOLD low

    ; Wait for HLDA to go HIGH (active high - bus granted)
    wait 1 gpio HLDA_PIN    ; No side-set needed, HOLD stays driven low

    ; Release HOLD by disabling output (tri-state, lets it float high)
    nop         side 0      ; Side-set pindir=0 (input/tri-state), HOLD floats high

    ; Timing delay - with optional side-set, max delay is still 7
    ; Using multiple nop[7] to achieve the desired delay
    nop [7]                 ; No side-set needed, HOLD stays high
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]
    nop [7]                 ; Total: 12 x 8 = 96 cycles

.wrap  ; Loop back to beginning

% c-sdk {
#include "hardware/gpio.h"

// SAFE helper function to initialize the test_hold_hlda program
// Uses open-drain signaling: output value is always 0, control via pin direction
static inline void test_hold_hlda_program_init(PIO pio, uint sm, uint offset) {
    // Just use the pin numbers directly
    const uint hold_pin = 25;  // Side-set pindirs pin
    const uint hlda_pin = 28;  // Input pin

    // Get the default config
    pio_sm_config c = test_hold_hlda_program_get_default_config(offset);

    // Configure side-set pins - HOLD_PIN (25) for direction control
    sm_config_set_sideset_pins(&c, hold_pin);

    // Initialize HOLD pin for PIO control
    pio_gpio_init(pio, hold_pin);

    // CRITICAL for open-drain: Set HOLD output value to 0
    // When we enable output (pindir=1), it will drive low
    // When we disable output (pindir=0), it will tri-state/float
    pio_sm_set_pins(pio, sm, 0);  // HOLD output value = 0

    // Start with HOLD as input (tri-stated, will float high)
    pio_sm_set_consecutive_pindirs(pio, sm, hold_pin, 1, false);  // false = input

    // Initialize HLDA for PIO to read (input only)
    // Critical: On RP2350, must call pio_gpio_init even for inputs
    pio_gpio_init(pio, hlda_pin);

    // Explicitly ensure HLDA stays as input (never driven)
    gpio_set_dir(hlda_pin, GPIO_IN);

    // Initialize the state machine with our config
    pio_sm_init(pio, sm, offset, &c);

    // RP2350 workaround: Execute a dummy pindirs instruction
    // This unlocks the side-set pindirs functionality on RP2350
    pio_sm_exec(pio, sm, pio_encode_set(pio_pindirs, 0));  // Start with HOLD tri-stated

    // Enable the state machine
    pio_sm_set_enabled(pio, sm, true);
}
%}