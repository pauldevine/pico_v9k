.pio_version 1
.define CLOCK_15B_PIN 31 
.define CLOCK_5_PIN  30
.define ALE_PIN 24 
.define RD_PIN 21
.define READY_PIN 28

.define ADDRESS_RD_WR_SIZE 22
.define ADDRESS_BUS_SIZE 20
.define REGISTER_SIZE 12
.define DATA_SIZE 8

.define FIFO_REG_READ    0x00
.define FIFO_WRITE_VALUE 0x01
.define FIFO_DMA_READ    0x02


.program board_registers
.side_set 1 

; --- Pre-amble ---
; This code runs once at the start for each state machine initialization
; It expects a bitmask of the 12 MSBs of the address to target for the board registers
pull block side 0        ; Pull bitmask for the 0xEF300 MSB that I'll match against later
out y, 12 side 0        ; Store bitmask in Y register for 12 MSB address comparison later

.wrap_target
T0:
    mov isr, null side 0                 ; clear ISR
    wait 0 GPIO CLOCK_5_PIN side 0       ; Wait for CLK5 to go low
    
T1:   
    wait 0 GPIO ALE_PIN side 0           ; wait for ALE to go low = T0 start & wait for address to stabilize
    wait 1 GPIO ALE_PIN [9] side 0       ; wait for ALE to go high = T1 start & wait for address to stabilize
    in pins, ADDRESS_BUS_SIZE side 0     ; shift 12 bits of address into ISR
    mov osr, isr side 0                  ; use OSR to store full 20-bit address for later
    in null, 20 side 0                   ; move the address into the lower 12 bits of the register, dropping 8 LSB to compare against 12 MSB bitmask
    mov x, isr side 0                    ; x = 12 MSB address bits
    jmp x!=y, T0 side 0                  ; if we're not at 0xEF300, restart T0 to try again
    mov isr, osr side 0                  ; restore full 20-bit address into ISR    // ISR has [20 bits address]
    set x, FIFO_REG_READ side 0          ; set x to REG_READ flag
    in x, 2 side 0 [10]                  ; move the REG_READ flag into ISR as MSBs // ISR has [00 payload flag][20 bits address]

T2:
    nop side 0 [15]                      ; delay for 1 cycle
    nop side 0 [15]                      ; delay for 1 cycle
    jmp pin T3_WRITE side 0              ; if RD pin is high 8088 is writing, if low 8088 is reading

T3_READ:                                 ; 8088 read cycle // pico's writing (bus_output_helper handles the push)
    wait 1 GPIO READY_PIN side 1 [15]    ; Wait for READY - gives ARM 800ns window to push data to bus_output_helper
    wait 1 GPIO RD_PIN side 1            ; wait for RD to go high (end of read cycle)
T4:
    nop side 0 [1]                      ; wait for next cycle
.wrap

T3_WRITE:                                ; 8088 write cycle // pico's reading
    wait 1 GPIO READY_PIN side 0         ; Wait for CLK5 to go high to allow data to stabilize
    mov isr, osr side 0                  ; restore full 20-bit address into ISR       // ISR has [20 bits address]
    set x, FIFO_WRITE_VALUE side 0 [15]  ; set x to WRITE_VALUE flag
    in pins, DATA_SIZE side 0            ; read data the 8088 is writing max 0xFF     // ISR has [8 bits data][20 bits address]
    in x, 2 side 0                       ; move the WRITE_VALUE flag into ISR as MSBs // ISR has [01 payload flag][8 bits data][20 bits address]
    push side 1                          ; send data to write to arm [payload flag 2 bits][data 8 bits][address 20 bits]
    jmp T4 side 0                        ; jump to T4 for the next clock cycle

% c-sdk {
#include <stdio.h>
#include "pico/error.h"
#include "pico_victor/dma.h"
#define ADDRESS_RD_WR_SIZE 22 
#define REG_PIN_FIRST BD0_PIN
#define REG_PIN_LAST DEN_PIN

static inline void board_registers_program_init(PIO pio, uint sm, uint offset) {
    pio_debug_state();
    debug_dump_pin(BD0_PIN);
    printf("starting to configure board_registers_program_init\n");
    pio_sm_config c = board_registers_program_get_default_config(offset);

    // init all the pins i'll be using as output
    for (int pin = REG_PIN_FIRST; pin <= REG_PIN_LAST; pin++) {
        gpio_set_drive_strength(pin, GPIO_DRIVE_STRENGTH_2MA);
        gpio_disable_pulls(pin);
        pio_gpio_init(pio, pin);
        gpio_pull_down(pin);
        gpio_set_slew_rate(pin, GPIO_SLEW_RATE_SLOW);
        pio_sm_set_pins_with_mask(pio, sm, 0u, 1u << pin); // preload latch low
        printf("pio_gpio_init %d\n", pin);
    }
    uint pincount = REG_PIN_LAST - REG_PIN_FIRST + 1;
    pio_sm_set_consecutive_pindirs(pio, sm, BD0_PIN, pincount, false);

    sm_config_set_in_pins(&c, BD0_PIN);
    sm_config_set_in_pin_count(&c, ADDRESS_BUS_SIZE);
    
    sm_config_set_jmp_pin(&c, RD_PIN); // RD pin is the pin we check for write vs read cycle

    //setup EXTIO as side-set to handle 8088 RD case
    //we need to assert EXTIO low when we want to send data to the 8088 processor
    //it takes the buffers for the 6522's out of the circuit so we don't loose the electrical battle
    //this isn't needed for writing to RAM in the DMA case
    pio_gpio_init(pio, EXTIO_PIN);
    sm_config_set_sideset_pins(&c, EXTIO_PIN);
    //set as pindirs as EXTIO is open drain, will only be pulling to 0
    sm_config_set_sideset(&c,
        1,     // bit_count: 1 pin for side-set
        false, // optional: side-set is mandatory on every instruction
        true   // pindirs: use side-set to control pin direction (for open-drain)
    );
    pio_sm_set_consecutive_pindirs(pio, sm, EXTIO_PIN, 1, true);
    printf("EXTIO_PIN Pin %d func: %d, dir: %d\n", 
           EXTIO_PIN, gpio_get_function(EXTIO_PIN), gpio_get_dir(EXTIO_PIN));
    pio_sm_set_pindirs_with_mask(pio, sm, 0, 1u << EXTIO_PIN); // preload value low
    
    //setup shift Registers
    sm_config_set_in_shift(&c, true, false, ADDRESS_BUS_SIZE);
    printf("Config execctrl before init: 0x%08x pinhi:0x%08x pinctrl:0x%08x\n",
            (uint32_t)c.execctrl, (uint32_t)c.pinhi, (uint32_t)c.pinctrl);

    
    sm_config_set_clkdiv(&c, 1.0f);  

    pio_sm_clear_fifos(pio, sm);

    // Load our configuration, and jump to the start of the program
    int init_rc = pio_sm_init(pio, sm, offset, &c);
    printf("board_registers pio_sm_init rc=%d, SM%d execctrl after init=0x%08x\n", init_rc, sm, pio->sm[sm].execctrl);
    if (init_rc == PICO_OK) {
        pio_sm_set_enabled(pio, sm, true);
    } else {
        printf("WARNING: pio_sm_init failed; SM%d not enabled\n", sm);
    }

    printf("finished configuring board_registers_program_init\n");
    printf("RD_PIN Pin %d func: %d, dir: %d\n", RD_PIN, gpio_get_function(RD_PIN), gpio_get_dir(RD_PIN));
    printf("WR_PIN Pin %d func: %d, dir: %d\n", WR_PIN, gpio_get_function(WR_PIN), gpio_get_dir(WR_PIN));

    pio_debug_state();
    debug_dump_pin(BD0_PIN);
}
%}
