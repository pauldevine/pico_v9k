.pio_version 1
.define IO_M_PIN 27
.define HLDA_PIN 29
.program iom_helper
.side_set 1 pindirs;

.wrap_target
;remember with wait and side-set the side-set happens before the wait condition is evaluated
;so the side-set value is applied before waiting, the logic below is inverted from what you might expect
    wait 1 GPIO HLDA_PIN side 0  ; wait for HLDA to go high, meaning we're doing DMA. Meanwhile keep IO/M/ input
    wait 0 GPIO HLDA_PIN side 1  ; wait for HLDA to go low, meaning DMA is done. Meanwhile keep IO/M/ output
.wrap

% c-sdk {
#include <stdio.h>
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "pico_victor/dma.h"

static inline void iom_helper_program_init(PIO pio, uint sm, uint offset) {
    uint io_m_offset = IO_M_PIN - 16; // PIO pins start at GPIO16 for this base
    printf("Configuring PIO for IOM helper SM\n");
    pio_sm_config c = iom_helper_program_get_default_config(offset);

    sm_config_set_sideset_pins(&c, IO_M_PIN, 1);
    pio_gpio_init(pio, IO_M_PIN);
    gpio_set_drive_strength(IO_M_PIN, GPIO_DRIVE_STRENGTH_2MA);
    gpio_set_slew_rate(IO_M_PIN, GPIO_SLEW_RATE_SLOW);
    gpio_disable_pulls(IO_M_PIN);
    pio_gpio_init(pio, HLDA_PIN);

    // preload latch low, will use pindirs to toggle low as needed
    pio_sm_set_pins_with_mask(pio, sm, 0u, 1u << io_m_offset); 
    pio_sm_set_consecutive_pindirs(pio, sm, io_m_offset, 1, false);
    
    sm_config_set_clkdiv(&c, 1.0f);  

    // Load our configuration, and jump to the start of the program
    int init_rc = pio_sm_init(pio, sm, offset, &c);
    printf("pio_sm_init rc=%d, SM%d execctrl after init=0x%08x\n", init_rc, sm, pio->sm[sm].execctrl);
}

%}