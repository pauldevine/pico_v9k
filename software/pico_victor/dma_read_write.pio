;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;
.pio_version 1 
.define CLOCK_15B_PIN 30 
.define CLOCK_5_PIN  29
.define READY_PIN 27
.define HLDA_PIN 28
.define ADDRESS_BUS_SIZE 20
.define ADDR_CONTROL_SIZE 27
.define CONTROL_PINCOUNT 12
.define DATA_SIZE 8

.program dma_read_write
.side_set 2 opt pindirs; 

; side-set GPIO Pin Mapping (LSB first):
; Bit 0 -> HOLD/  (GPIO 25)
; Bit 1 -> IO/M/  (GPIO 26)

.define SIDE_HOLD_RELEASE_IO_INPUT 0b00
.define SIDE_HOLD_ASSERT_IO_INPUT  0b01
.define SIDE_HOLD_RELEASE_IO_OUTPUT 0b10
.define SIDE_HOLD_ASSERT_IO_OUTPUT  0b11

; Set pins
; Bit 0 -> RD/ (GPIO 20)
; Bit 1 -> WR/ (GPIO 21)
; Bit 2 -> DT/R/ (GPIO 22)
; Bit 3 -> ALE  (GPIO 23)
; Bit 4 -> DEN/ (GPIO 24)

; TX FIFO data format:
; Bit 0:     R/W flag (0=Read, 1=Write)
; Bits 1-20: A0-A19 Address (shifted left by 1)
; Bits 21-28: Data byte for writes (0x00 for reads)
; Bits 29-31: Unused
;
; Example FIFO word format:
; Write: 0x[DATA][ADDR<<1 | 1]  where LSB=1 for write
; Read:  0x[0x00][ADDR<<1 | 0]  where LSB=0 for read

.wrap_target
T0:                                ; Address Setup Phase (Put Address on Bus)
    pull block                     ; Block if FIFO empty (HOLD stays released!)
    out x, 1                       ; Get R/W bit from LSB (0=Read, 1=Write)
    set pins, 0b11111 side SIDE_HOLD_ASSERT_IO_INPUT ; Assert HOLD/, keep IO/M/ input during request
    out pins, ADDRESS_BUS_SIZE     ; Output A0-A19 on bus, pindirs still input
    out y, 8                       ; get data byte from FIFO, either data to write or 0x00 for read
    wait 1 gpio HLDA_PIN           ; wait for HLDA to go high
T1:
    mov OSR, ~null                 ; Set OSRs to all 1 to prepare for pindirs next line
    out pindirs, 20 side SIDE_HOLD_ASSERT_IO_OUTPUT  ; Drive address pins, keep HOLD/ asserted, IO/M/ output
    set pindirs, 0b11111           ; Set control pins to output DEN=1, ALE=1, DT/R=1, WR/=1, RD=1 //ALE high to latch address
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high
    wait 1 GPIO CLOCK_15B_PIN      ; Wait for CLK15B to go high
T2:
    jmp !x T2_WRITE                ; If write, jump to T2_WRITE
    set pins, 0b00010              ; else reading here, set control pins for RD control DEN=0, ALE=0, DT/R=0, WR=1, RD=0
    mov OSR, y                     ; Move data byte stored above to OSR for pindirs setup
    out pindirs, 8                 ; set BD0-BD7 pins to input for RD cycle / earlier payload had 0x00 for this purpose
T2_CONTINUE:
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high, 
    wait 0 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go low
    wait 1 GPIO READY_PIN          ; Wait for READY to go high
T3:
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high
    wait 0 GPIO CLOCK_5_PIN side SIDE_HOLD_RELEASE_IO_OUTPUT ; Wait for CLK5 to go low, release HOLD/, keep IO/M/ output
    jmp !x T4                      ; skip in pins if write
    in pins, DATA_SIZE             ; RD case, read data from bus
T4:
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high
    set pins, 0b00111              ; Set control pins to T4 start, DEN=0, ALE=0, DT/R=1, WR=1, RD=1
    set pins, 0b10111              ; Set control pins to T4 close, DEN=1, ALE=0, DT/R=1, WR=1, RD=1
    wait 0 gpio HLDA_PIN side SIDE_HOLD_RELEASE_IO_OUTPUT ; wait for HLDA to go low, keep HOLD released
    set pindirs, 0b00000 side SIDE_HOLD_RELEASE_IO_INPUT ; Set control pins' direction to input / release IO/M and HOLD
    mov pindirs, NULL              ; Tri-state all address outputs (Release Bus)

.wrap

T2_WRITE:
    mov OSR, y             ; Move data byte stored above to OSR for output
    out pins, DATA_SIZE    ; DMA write, output A0-A7 with data value, A8-A19 continues to hold MSB of address which needs to remain stable 
    set pins, 0b00101      ; set control pins for WR control DEN=0, ALE=0, DT/R=1, WR=0, RD=1
    jmp T2_CONTINUE                

% c-sdk {
#include <stdio.h>
#include <string.h>
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "hardware/clocks.h"
#include "pico_victor/dma.h"
#define OUTPUT_PIN_FIRST BD0_PIN
#define OUTPUT_PIN_LAST  IO_M_PIN

// Helper macros to format data for the new FIFO format
// For writes: R/W=1, address shifted left by 1, data in upper byte
#define DMA_FORMAT_WRITE(addr, data) (((uint32_t)(data) << 21) | ((addr) << 1) | 1)
// For reads: R/W=0, address shifted left by 1, data byte is 0x00
#define DMA_FORMAT_READ(addr) ((addr) << 1)


/*
 * CRITICAL PIN INITIALIZATION RULES:
 *
 * Output pins (controlled by PIO via pindirs):
 *   - A0-A19 (address bus) - pins 0-19
 *   - RD/, WR/, DT/R/, ALE, DEN/ (control outputs) - pins 20-24
 *   - HOLD/, IO/M/ (side-set outputs) - pins 25-26
 *   - HOLD is active low, and setup for open-drain on the Victor 9000. 
 *     We pull HOLD low to assert, and release to float high via 10K pullup on the Victor board
 *     Hence we use pindirs to control HOLD - output=assert, input=release
 *   USE: pio_gpio_init() to give PIO full control including pin direction
 *
 * Input-only pins (read by PIO wait instructions):
 *   - READY - pin 27
 *   - HLDA - pin 28
 *   - CLOCK_5 - pin 29
 *   - CLOCK_15B - pin 30
 *   - IR pins - pins 31+
 *   USE: ONLY gpio_set_function(pin, GPIO_FUNC_PIO0/1/2) to route to PIO
 *   DO NOT use gpio_init() (sets wrong function) or pio_gpio_init() (gives unwanted pindirs control)
 *
 * Why this matters:
 *   - PIO wait instructions require the pin to be routed to PIO via function mux
 *   - If a pin isn't routed to PIO, wait will hang forever
 *   - Using pio_gpio_init() on input-only pins causes them to glitch when pindirs changes
 */
static inline void dma_read_write_program_init(PIO pio, uint sm, uint offset, uint pin) {
    printf("Configuring PIO for DMA READ/WRITE operations (single SM)\n");
    printf("starting to configure dma_read_write_program_init\n");
    pio_sm_config c = dma_read_write_program_get_default_config(offset);

    printf("setting out pin mapping to %d, count %d\n", pin, ADDRESS_BUS_SIZE);
    sm_config_set_out_pins(&c, pin, ADDRESS_BUS_SIZE);
    printf("setting set pin mapping to %d, count 5\n", RD_PIN);
    sm_config_set_set_pins(&c, RD_PIN, 5);
    printf("setting sideset pin mapping to %d, count 2\n", HOLD_PIN);
    sm_config_set_sideset_pins(&c, HOLD_PIN);
    sm_config_set_sideset(&c, 3, true, true);  // 3 bits total: 1 optional bit + 2 pin bits for ".side_set 2 opt"
    // Don't set pindirs here - it will be overridden by line 157

    // Shift Register configuration settings
    // Configure for both read and write operations
    printf("Configuring in/out pins for read/write mode\n");
    sm_config_set_in_pins(&c, BD0_PIN);
    sm_config_set_in_pin_count(&c, DATA_SIZE);
    // Note: With R/W bit in LSB, we need 29 bits total (1 + 20 + 8)
    // MUST disable autopull when using pull ifempty - otherwise OSR fills with zeros
    sm_config_set_out_shift(&c, true, false, 32);  // Right shift, NO autopull
    sm_config_set_in_shift(&c, false, true, DATA_SIZE);
    
    pio_sm_clear_fifos(pio, sm);
    pio_sm_set_clkdiv(pio, sm, 1.0f);

    // Init output pins for PIO first
    for (int i = pin; i <= IO_M_PIN; i++) {
        gpio_set_drive_strength(i, GPIO_DRIVE_STRENGTH_12MA);
        pio_gpio_init(pio, i);
        printf("dma gpio_init %d  ", i);
        printf("GPIO%d_CTRL = 0x%08x\n", i, io_bank0_hw->io[i].ctrl);
    }

    // Now init input-only pins for PIO
    uint func = GPIO_FUNC_PIO0 + pio_get_index(pio);
    for (int pin = IO_M_PIN + 1; pin <= IR_4_PIN; ++pin) {
        ; gpio_set_function(pin, func);
        ; gpio_set_input_enabled(pin, true);
        gpio_set_drive_strength(pin, GPIO_DRIVE_STRENGTH_12MA);
        pio_gpio_init(pio, pin);
        printf("dma gpio_init %d  ", pin);
        printf("GPIO%d_CTRL = 0x%08x\n", pin, io_bank0_hw->io[pin].ctrl);
    }

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);

    // CRITICAL RP2350 WORKAROUND: The PIO side-set pindirs doesn't work until
    // the state machine has executed at least one explicit pindirs instruction!
    // Execute a dummy pindirs instruction to "unlock" side-set pindirs functionality
    // We set HOLD as output initially to ensure it starts released (via pull-up)
    pio_sm_exec(pio, sm, pio_encode_set(pio_pindirs, 0));  // First set all as inputs
    pio_sm_exec(pio, sm, pio_encode_set(pio_pindirs, (1u << 25)));  // Then set HOLD as output
    pio_sm_exec(pio, sm, pio_encode_set(pio_pindirs, 0));  // Finally back to all inputs (HOLD released)

    // Just ensure HOLD and IO/M pin VALUES start at 0
    // (HOLD will be controlled via pindirs - output=assert, input=release)
    pio_sm_set_pins_with_mask(pio, sm, 0, (1u << IO_M_PIN) | (1u << HOLD_PIN));

    // Debug: Check the actual SM configuration
    uint32_t pinctrl = pio->sm[sm].pinctrl;
    uint32_t execctrl = pio->sm[sm].execctrl;
    printf("SM%d PINCTRL = 0x%08x\n", sm, pinctrl);
    printf("  SIDESET_COUNT = %d\n", (pinctrl >> 29) & 0x7);
    printf("  SET_COUNT = %d\n", (pinctrl >> 26) & 0x7);
    printf("  OUT_COUNT = %d\n", (pinctrl >> 20) & 0x3F);
    printf("  IN_BASE = %d\n", (pinctrl >> 15) & 0x1F);
    printf("  SIDESET_BASE = %d\n", (pinctrl >> 10) & 0x1F);
    printf("  SET_BASE = %d\n", (pinctrl >> 5) & 0x1F);
    printf("  OUT_BASE = %d\n", pinctrl & 0x1F);
    printf("SM%d EXECCTRL = 0x%08x\n", sm, execctrl);
    printf("  SIDE_EN = %d\n", (execctrl >> 30) & 0x1);
    printf("  SIDE_PINDIR = %d\n", (execctrl >> 29) & 0x1);

    // Don't enable the state machine here - it will be enabled when needed
    // pio_sm_set_enabled(pio, sm, true);
    printf("finished configuring dma_controller_program_init\n");
}
%}
