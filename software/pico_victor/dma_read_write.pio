;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;
.pio_version 1 
.define CLOCK_15B_PIN 30 
.define CLOCK_5_PIN  29
.define READY_PIN 27
.define HLDA_PIN 28
.define ADDRESS_BUS_SIZE 20
.define ADDR_CONTROL_SIZE 27
.define CONTROL_PINCOUNT 12
.define DATA_SIZE 8

.program dma_read_write
.side_set 2 opt pindirs; 

; side-set GPIO Pin Mapping:
; Bit 0 -> HOLD/  (GPIO 25)
; Bit 1 -> IO/M/  (GPIO 26)

; Set pins
; Bit 0 -> RD/ (GPIO 20)
; Bit 1 -> WR/ (GPIO 21)
; Bit 2 -> DT/R/ (GPIO 22)
; Bit 3 -> ALE  (GPIO 23)
; Bit 4 -> DEN/ (GPIO 24)

; --- Pre-amble ---
; Setup registers to differentiate between read and write
; This code runs once at the start for each state machine initialization
; Because the SM only loads the program once, we can run two instances that 
; differ only in the initial setup of the X register to indicate read or write mode
out x, 32          ; Store DMA direction in X 0= Read, 1=Write

; TX FIFO data format for WRITE mode
; Word 0:  A0-A19 Address + 1 byte of data to be written
; TX FIFO for READ mode
; Word 0:  A0-A19 Address + 1 byte (0x00) for pin   direction setup for read
.wrap_target
T0:                                ; Address Setup Phase (Put Address on Bus)
    out pins, ADDRESS_BUS_SIZE     ; prepare bus address to T1 state, A0-A19 on bus, pindirs still input
    set pins, 0b11111 side 0b01    ; prepare control pins to T1 state, pindir OUT for HOLD output requesting bus, others input
    out y, 8                       ; get data byte from FIFO, either data to write or 0x00 for read
    wait 1 GPIO HLDA_PIN           ; wait for HLDA to go high
T1:
    
    mov pindirs, ~null side 0b11   ; Set all address pins' direction to output / IO/M output / HOLD output
    set pindirs, 0b11111           ; Set control pins to output
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high
    wait 0 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go low
T2:
    jmp !x T2_WRITE                ; If write, jump to T2_WRITE 
    set pins, 0b00010              ; else reading here, set control pins for RD control DEN=0, ALE=0, DT/R=0, WR=1, RD=0
    mov OSR, y                     ; Move data byte stored above to OSR for pindirs setup
    out pindirs, 8                 ; set BD0-BD7 pins to input for RD cycle / earlier payload had 0x00 for this purpose
T2_CONTINUE:
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high, 
    wait 0 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go low
    wait 1 GPIO READY_PIN          ; Wait for READY to go high
T3:
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high
    wait 0 GPIO CLOCK_5_PIN side 0b10 ; Wait for CLK5 to go low, stop driving HOLD low, release HOLD
    jmp !x T4                      ; skip in pins if write
    in pins, DATA_SIZE             ; RD case, read data from bus
T4:
    wait 1 GPIO CLOCK_5_PIN        ; Wait for CLK5 to go high
    set pins, 0b00111              ; Set control pins to T4 start, DEN=0, ALE=0, DT/R=1, WR=1, RD=1
    wait 1 GPIO CLOCK_15B_PIN      ; Wait for CLK15B to go low
    set pins, 0b10111              ; Set control pins to T4 close, DEN=1, ALE=0, DT/R=1, WR=1, RD=1
    wait 0 GPIO HLDA_PIN           ; wait for HLDA to go low 
    set pindirs, 0b00000 side 0b00 ; Set all control pins' direction to input / tri-state control pins
    mov pindirs, NULL              ; Tri-state all address outputs (Release Bus)

.wrap

T2_WRITE:
    mov OSR, y             ; Move data byte stored above to OSR for output
    out pins, DATA_SIZE    ; DMA write, output A0-A7 with data value, A8-A19 continues to hold MSB of address which needs to remain stable 
    set pins, 0b00101      ; set control pins for WR control DEN=0, ALE=0, DT/R=1, WR=0, RD=1
    jmp T2_CONTINUE                

% c-sdk {
#include <stdio.h>
#include <string.h>
#include "hardware/pio.h"
#include "hardware/gpio.h"
#include "hardware/clocks.h"
#include "pico_victor/dma.h"
#define OUTPUT_PIN_FIRST BD0_PIN
#define OUTPUT_PIN_LAST  IO_M_PIN


static inline void dma_read_write_program_init(PIO pio, uint sm, uint offset, uint pin, bool read) {
    char* mode;
    if (read) {
        printf("Configuring PIO for DMA READ operation\n");
        mode = "READ";
    } else {
        printf("Configuring PIO for DMA WRITE operation\n");
        mode = "WRITE";
    }

    printf("starting to configure dma_read_write_program_init\n");
    pio_sm_config c = dma_read_write_program_get_default_config(offset);

    printf("setting out pin mapping to %d, count %d\n", pin, ADDRESS_BUS_SIZE);
    sm_config_set_out_pins(&c, pin, ADDRESS_BUS_SIZE);
    printf("setting set pin mapping to %d, count 5\n", RD_PIN);
    sm_config_set_set_pins(&c, RD_PIN, 5);
    printf("setting sideset pin mapping to %d, count 2\n", HOLD_PIN);
    sm_config_set_sideset_pins(&c, HOLD_PIN);
    sm_config_set_sideset(&c, 2, true, true);
    pio_sm_set_consecutive_pindirs(pio, sm, HOLD_PIN, 2, true);

    //Shift Register configuration settings
    if (read) {
        printf("Configuring in/out pins for read mode\n");
        sm_config_set_in_pins(&c, BD0_PIN);
        sm_config_set_in_pin_count(&c, DATA_SIZE);
        sm_config_set_out_shift(&c, true, true, ADDRESS_AND_DATA_SIZE);
        sm_config_set_in_shift(&c, false, true, DATA_SIZE);
    } else {
        printf("Configuring in/out pins for write mode\n");
        sm_config_set_out_shift(&c, true, true, ADDRESS_AND_DATA_SIZE);
    }
    
    pio_sm_clear_fifos(pio, sm);
    pio_sm_set_clkdiv(pio, sm, 1.0f);

    // Init ALL pins for PIO (required for wait instructions to work)
    for (int i = pin; i <= OUTPUT_PIN_LAST; i++) {
        pio_gpio_init(pio, i);
        gpio_set_drive_strength(i, GPIO_DRIVE_STRENGTH_12MA);
        printf("dma %s pio_gpio_init %d\n", mode, i);
        printf("GPIO%d_CTRL = 0x%08x\n", i, io_bank0_hw->io[i].ctrl);
    }

    for (int i = OUTPUT_PIN_LAST+1; i <= IR_4_PIN; i++) {
        gpio_init(i);
        gpio_set_dir(i, GPIO_IN);
        gpio_set_drive_strength(i, GPIO_DRIVE_STRENGTH_12MA);
        gpio_set_function(i, PIO_FUNCSEL_NUM(pio, i)); 
        pio_gpio_init(pio, i);
        printf("dma %s gpio_init %d\n", mode, i);
    }
    
    //setup HOLD and IO/M to have initial value of 0
    gpio_init(IO_M_PIN);
    gpio_put(IO_M_PIN, 0);

    gpio_init(HOLD_PIN);
    gpio_put(HOLD_PIN, 0);

    // Set all pins as inputs initially
    pio_sm_set_consecutive_pindirs(pio, sm, pin, OUTPUT_PIN_LAST+1, false);

    // Load our configuration, and jump to the start of the program
    pio_sm_init(pio, sm, offset, &c);
    // Don't enable the state machine here - it will be     enabled when needed
    // pio_sm_set_enabled(pio, sm, true);
    printf("finished configuring dma_controller_program_init %s\n", mode);
}
%}
